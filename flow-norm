#! /bin/python3


## Note: in this state, this program is memory intensive. 
import pandas as pd
from argparse import ArgumentParser
import subprocess
import sys
import re
import os
from shutil import copyfile


def query_yes_no(question, default="yes"):
    valid = {"yes": True, "y": True, "ye": True, "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = input().lower()
        if default is not None and choice == "":
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' " "(or 'y' or 'n').\n")

def make_stats(fast_file):
    stat_file = fast_file.split('.fast')[0] + '-stats.txt'
    cmd = "seqkit stats " + fast_file +" > " +stat_file
    # print(cmd)
    subprocess.run(cmd, shell=True)
    return stat_file

def get_reads(stat_file):
    with open(stat_file, 'r') as f:
        lines=f.readlines()
        reads=((lines[1].split())[3]).replace(",", "")
        return reads

def get_bases(stat_file):
    with open(stat_file, 'r') as f:
        lines=f.readlines()
        bases=((lines[1].split())[4]).replace(",", "")
        return bases

def reformat_read(in_file, out_file, reads):
    cmd = "reformat.sh qin=33 ow=t reads=" + str(reads) + " in=" + in_file + " out=" + out_file
    print(out_file)
    subprocess.run(cmd, shell=True)

def reformat_base(in_file, out_file, bases, reads):
    make_stats(in_file)
    all_bases = int(get_bases((in_file).split('.fast')[0] + '-stats.txt'))
    if (bases == all_bases):
        copyfile(in_file, out_file)
        make_stats(out_file)
    else:
        # cmd = "seqkit fq2fa " + in_file + " -o " +  in_file.split('.')[0] + '.fasta'
        # subprocess.run(cmd, shell=True)

        list_bases = 0
        i = 0     
        with open(in_file) as fileobject:
            for line in fileobject:
                line = line.rstrip()
                i +=1 # count the lines

                if i % 4 == 2:
                    list_bases += (len(line))
                    if (list_bases > bases):
                        break
        # i + 2 to add the two missing lines to complete the fastq read. Divide by four to get the number of reads

        cmd = "reformat.sh qin=33 ow=t reads=" + str((i+2)/4) + " in=" + in_file + " out=" + out_file
        subprocess.run(cmd, shell=True)
        make_stats(out_file)
        more_bases = int(get_bases(out_file.split('.fast')[0] + '-stats.txt'))
        cmd = "reformat.sh qin=33 ow=t reads=" + str(((i+2)/4)-1) + " in=" + in_file + " out=" + out_file
        subprocess.run(cmd, shell=True)
        make_stats(out_file)
        less_bases = int(get_bases(out_file.split('.fast')[0] + '-stats.txt'))
        if abs(less_bases - bases) > abs(more_bases - bases):
            cmd = "reformat.sh qin=33 ow=t reads=" + str(((i+2)/4)) + " in=" + in_file + " out=" + out_file
            subprocess.run(cmd, shell=True)
            make_stats(out_file)

    #No need for else as the files were just created


def main():
    parser = ArgumentParser('description')
    parser.add_argument('--fastq', '-i', '-f', action='store', dest='fastq', type=str, nargs='*',help='fastq files to normalize')
    parser.add_argument('--outdir', '-o', action='store', dest='outdir', type=str, default = os.getcwd())
    files = parser.parse_args()
    df = pd.DataFrame(files.fastq, columns = ['File path'])
    df['File name'] = df['File path'].str.split('/').str[-1]
    # print(df['File name'])
    df['RUNID'] = ''
    df['barcode'] = ''
    full_name = ''
    for index, row in df.iterrows():
        if row['File name'][0].isdigit():
            print('file is illumina')
            df.loc[index, 'RUNID'] = (re.search('(.*)-', row['File name'])).group(1)
            df.loc[index, 'barcode'] = (re.search('-(.*)_seqtk_trimfq', row['File name'])).group(1)
            print("WARNING: Illumina reads not handled because which of P1 or P2 should be used?")
            exit()
        else:
            df.loc[index, 'RUNID'] = (re.search('(.*)-barcode', row['File name'])).group(1)
            # print(row['RUNID'])
            df.loc[index, 'barcode'] = (re.search(row['RUNID']+'-(.*)-seqtk-trimfq', row['File name'])).group(1)
        full_name+= '-'+row['RUNID'] +'-'+row['barcode']
    df = df[['RUNID', 'barcode', 'File name', 'File path']]
    full_name = full_name.replace("barcode","bc")
    print(df.to_string())
    
    question = "\nDoes the information above correspond to the files you want to normalise?\n"

    # if query_yes_no(question, default = "yes"):
    df['Reads'] = 0
    df['Bases'] = 0
    df['Reads after read normalisation'] = 0
    df['Reads after base normalisation'] = 0
    df['Bases after read normalisation'] = 0
    df['Bases after base normalisation'] = 0
    df['Output file reads'] = ''
    df['Output file bases'] = ''
    df['Output file reads stats'] = ''
    df['Output file bases stats'] = ''
    df = df.reset_index(drop=True)

    for index, row in df.iterrows():
        stats = make_stats(row['File path'])
        df.loc[index, 'Reads'] = get_reads(stats)
        df.loc[index, 'Bases'] = get_bases(stats)
        df.loc[index, 'Output file reads'] = files.outdir+'/'+row['File name'].replace("-seqtk-trimfq.","-normalised-reads-with"+full_name+".")
        df.loc[index, 'Output file bases'] = files.outdir+'/'+row['File name'].replace("-seqtk-trimfq.","-normalised-bases-with"+full_name+".")
    df['Reads'] = df['Reads'].astype(int)
    df['Bases'] = df['Bases'].astype(int)
    min_read_nb = df['Reads'].min()
    min_base_nb = df['Bases'].min()
    print(min_read_nb)
    print(min_base_nb)
    print(df.to_string())


    for index, row in df.iterrows():

        print(row['File path'].replace("-seqtk-trimfq.",full_name+"normalised-reads."))

        reformat_read(row['File path'], row['Output file reads'], min_read_nb)
        reformat_base(row['File path'], row['Output file bases'], min_base_nb, min_read_nb)

        df.loc[index, 'Output file reads stats'] = make_stats(row['Output file reads'])
        df.loc[index, 'Output file bases stats'] = make_stats(row['Output file bases'])

    for index, row in df.iterrows():
        df.loc[index, 'Reads after read normalisation'] = get_reads(row['Output file reads stats'])
        df.loc[index, 'Bases after read normalisation'] = get_bases(row['Output file reads stats'])
        df.loc[index, 'Reads after base normalisation'] = get_reads(row['Output file bases stats'])
        df.loc[index, 'Bases after base normalisation'] = get_bases(row['Output file bases stats'])


    df = df[['RUNID', 'barcode', 'Reads', 'Bases', 'Reads after read normalisation', 'Bases after read normalisation', 'Reads after base normalisation','Bases after base normalisation']]
    df.to_csv(files.outdir + '/normalise-summary'+full_name+'.csv', index = False, sep = '\t')

    print(df.to_string())


if __name__ == "__main__":
    main()
